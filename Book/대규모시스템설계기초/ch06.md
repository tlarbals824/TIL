# 6장 키-값 저장소 설계

키-값 저장소는 비 관계형 데이터베이스입니다. 대표적으로 레디스, memcached, 다이나모 등이 있습니다.

## 단일 서버 키-값 저장소

단일 서버의 저장소를 설계하는 것은 어렵지 않습니다. 자료구조를 활용해서 바로 구현할 수 있고, 영속성을 제공한다면 디스크에 데이터를 저장할 수 있습니다. 다만, 메모리에 전부 저장한다면 데이터 압축을 활용해야 합니다.

## 분산 키-값 저장소

### CAP

CAP은 데이터 일관성(consistency), 가용성(availability), 파티션 감내(partition tolerance) 세 가지 요구사항을 만족하는 분산 시스템은 불가능하다는 정리입니다.

* 데이터 일관성: 어느 노드에 접속하더라도 같은 값을 조회할 수 있습니다.
* 가용성: 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있습니다.
* 파티션 감내: 네트워크 단절로 클러스터가 두 개 생기더라도 시스템은 계속 동작합니다.

위 3개 중 2개 요구사항을 만족하는 경우는 다음과 같습니다.

* CP 시스템: 가용성을 희생한 시스템, 일부 노드 장애가 발생하면 모든 노드로 전파됩니다.
* AP 시스템: 일관성을 희생한 시스템, 노드간 조회되는 데이터가 다를 수 있습니다.
* CA 시스템: 파티션 감내를 희생한 시스템, 하지만 네트워크 장애는 피할 수 없어서 통상적으로 해당 시스템은 존재할 수 없습니다.

## 데이터 파티션

데이터를 작은 단위로 분리한 다음 여러 노드에 분산 저장하는 경우 데이터 파티션이라고 합니다. 이전 장에서의 안정 해시가 데이터 파티션의 대표적인 예입니다.

데이터 파티션을 사용하면 규모 확장이 쉬워지고, 각 노드의 성능에 따라 데이터 분산을 유동적으로 할 수 있습니다.

## 데이터 다중화

높은 가용성과 안전성을 위해 데이터를 N개의 노드에 동시에 저장해야 합니다. 이를 통해 특정 데이터센터의 장애가 발생하더라도 가용성을 유지할 수 있습니다.

## 데이터 일관성

여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 합니다. 쿼럼 프로토콜을 사용하면 읽기/쓰기 연산 모두 일관성을 유지할 수 있습니다. 예로는 카프카에서 복제에서 흔히 사용됩니다.

## 비 일관성 해소 기법: 데이터 버저닝

두 노드에 동시에 쓰기 요청이 들어올 경우 데이터 쓰기 충돌이 발생할 수 있습니다. 이에 대해서 두 노드 사이에 조율할 수단이 필요합니다. 이때 백터 시계를 통해 충돌을 조율합니다.

백터 시계는 서버 id와 요청 시간을 쌍으로 저장합니다. 각 요청에 대해서 값을 저장하고 이에 대해 수정하지 못합니다. 그렇다면 두 요청이 들어올 때, 요청 시간 비교로 정렬하고 가장 최근에 들어온 요청에 대해서 값을 반영합니다.

이러한 기술을 aws DynamoDB에서 사용합니다. PostgreSQL의 multi-active는 백터 시계와 유사하게 어느 서버에서 어느 시간에 요청된지 확인하고 가장 최신 요청을 커밋하는 방식을 사용합니다.

## 장애 처리

### 장애 감지

분산 시스템에서는 특정 노드에 장애가 발생할 때, 나머지 노드들 중 일정 수 이상의 노드에서 장애가 감지 되면 그때 장애가 발생했다고 간주합니다. 예로는 Redis의 가십(gossip) 프로토콜을 통해 장애를 감지하고 fail over를 진행합니다.

이와 반대로 원래 복제 대상 노드가 죽어 있어도 “대체 가능한 다른 노드들”에 쓰기를 임시로 기록해 정족수 조건을 맞추는 방식인 "느슨한 정족수"가 있습니다. 예로는 DynamoDB가 있습니다. 이는 가용성을 위한 조치입니다.

### 데이터 동기화

머클 트리는 일종의 해시 트리(hash tree)로, 리프 노드에는 실제 데이터(트랜잭션·레코드·파일 조각 등)의 해시가 들어가고, 상위 노드들은 “자식 해시 둘을 합쳐 다시 해싱한 값”을 저장합니다. 이를 통해 특정 노드의 데이터가 불일치하는 경우 이를 감지하고 동기화할 수 있습니다. 예로는 DynamoDB가 있습니다.