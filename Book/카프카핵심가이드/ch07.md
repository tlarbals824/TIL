# 7장 신뢰성 있는 데이터 전달

## 7.1 신뢰성 보장

* 카프카는 다음을 보장해준다.
  * 메시지의 순서: 토픽 내의 같은 파티션이라면 메시지의 순서가 보장된다.
  * 메시지 지속성 보장: 메시지가 들어오면 ISR에 모두 저장되면 해당 데이터에 대해 커밋된 것으로 간주한다.
  * 메시지 신뢰성 보장: 파티션을 담당하는 레플리카가 하나라도 살아있다면 메시지는 손실되지 않는다.
  * 메시지 일관성 보장: 컨슈머는 커밋된 데이터만 읽을 수 있다.
* 앞선 보장들을 통해서 신뢰성 있는 시스템을 구축할 수 있지만, 시스템 전체를 완전히 신뢰성 있게 만들어주지 않는다.
* 신뢰성을 위해서는 트레이드오프가 있으며, 이를 조절하여 시스템을 구축해야 한다.

## 7.2 복제

* 카프카의 복제 메커니즘은 파티션별로 다수의 레플리카를 유지한다는 특성과 함계 신뢰성 보장의 핵심이다.
* 레플리카는 파티션의 리더 레플리카이거나 아니면 다음 조건을 만족하는 팔로워 레플리카인 경우 ISR로 간주한다.
  * 주키퍼와 활성 세션이 있다.
  * 최근 10초 사이 리더로부터 메시지를 읽어왔다.
  * 최근 10초 사이에 리더로부터 읽어온 메시지들이 가장 최근 메시지이다.
* 레플리카가 OSR 상태가 되면, 리더 레플리카의 최근 메시지까지 따라잡을 때까지 ISR에 포함되지 않는다.
* 동기화가 살짝 느린 ISR이 있다면, 프로듀서와 컨슈머에 지연을 초래할 수 있다.
  * 이를 ISR의 수를 줄이면 해결할 수 있지만, 반대로 데이터 유실 위험성이 커지게 된다.

## 7.3 브로커 설정

* 토픽 단위의 설정을 카프카에서는 제공하고 있다.
  * 토픽 단위의 설정은 해당 토픽의 신뢰성이 필요한지의 유무에 따라 달라진다.

### 7.3.1 복제 팩터

* 토픽 단위 설정은 replication.factor에, 자동으로 생성되는 토픽들에 적용되는 브로커 단위 설정은 default.replication.factor 설정에 잡아둔다.
* 복제 팩터가 N이라고 할때 N-1개의 브로커가 중단되더라도 데이터를 읽을 수 있다. 하지만, 데이터를 쓰는 과정에서 N번의 복제가 발생하기에 성능상에 트레이드 오프가 있다.
* 토픽의 적절한 레플리카 수를 설정하기 위해서는 다음과 같은 고려사항이 있다.
  * 가용성: 레플리카가 적을수록 시스템 전체가 작동 불가능할 확률이 높아진다.
  * 지속성: 레플리카가 적을수록 시스템이 중단될 경우 데이터가 유실될 가능성이 커진다.
  * 처리량: 레플리카가 많을수록 데이터 복제에 의한 트래픽이 많아진다. 즉, 처리량이 감소하게 된다.
  * 종단 지연: ISR 내의 레플리카가 많을수록 지연이 발생할 가능성이 커진다.
  * 비용: 레플리카가 많을수록 저장소와 네트워크 비용이 커진다.
* 레플리카의 위치를 설정할 때, 레플리카간 다른 물리적 위치에 둠으로써 가용성을 높일 수 있다.

### 7.3.2 언클린 리더 선출

* 리더 선출 시 ISR에 포함된 레플리카를 리더로 선출하는 것을 '클린'하다고 한다.
* 만약 ISR에 포함된 레플리카가 리더 레플리카만 있다면, 리더 레플리카가 중단되면 어떻게해야할까?
  * 리더가 복구될때까지 대기한다.
  * OSR 중 하나를 선택하여 리더로 선출하고, 이전 리더가 가진 데이터는 유실된다.
* OSR이 리더가 될 수 있다면, 데이터 유실과 일관성 꺠짐의 위험성이 있다.
* unclean.leader.election.enable 이 true가 된다면 OSR이 리더가 될 수 있다. 기본은 false이다.

### 7.3.3 최소 ISR

* 토픽과 브로커 모두 min.insync.replicas 설정을 할 수 있다.
* min.insync.replicas 설정은 ISR에 포함되어야 하는 최소 레플리카 수를 의미한다. ISR의 수가 설정값보다 작은 경우
쓰기는 불가능한 상태로 변한다. 즉, 읽기만 가능하게 된다.

### 7.3.4 레플리카를 인-싱크 상태로 유지하기

* 카프카는 주키퍼와의 설정 그리고 리더와의 연결 설정을 통해 클러스터의 민감도를 조절할 수 있다.
* zookeeper.session.timeout.ms를 통해 주키퍼와의 세션 타임아웃을 설정할 수 있다.
* replica.lag.time.max.ms에 설정된 값을 통해 ISR의 레플리카가 리더로부터 데이터를 받지 않는 시간을 설정할 수 있다.

### 7.3.5 디스크에 저장하기

* 카프카는 세그먼트를 교체하거나 재시작하기 전까지는 디스크를 메모리에 캐싱한다.
* 디스크에 바로 반영하지 않는 이유는 디스크에 바로 반영하게 되면 디스크 I/O가 많아지게 되어 성능이 저하되며 레플리카들이 메시지를 복제하는 것이 안전하다고 판단됐기 때문이다.

## 7.4 신뢰성 있는 시스템에서 프로듀서 사용하기

* 브로커뿐만 아닌 프로듀서또한 신뢰성있는 설정을 해야지만 시스템의 신뢰성을 확보할 수 있다.
* 만약 acks=1이라면 ISR들에 복제가 되기 전에 리더가 중단이된다면, 프로듀서는 성공했지만 메시지는 유실될 수 있다.
* 리더 선출 과정에서 메시지 전송시, "Leader not Available"응답에 대해 적절한 재시도가 없다면 프로듀서는 메시지를 유실할 수 있다.
* 위 두 경우를 통해 다음 항목을 신경써야함을 알 수 있다.
  * 신뢰성 요구 조건에 맞는 올바른 acks 설정
  * 설정과 코드 모두에서 에러를 올바르게 처리

### 7.4.1 응답 보내기

* acks=0
  * 프로듀서는 리더에게 메시지를 보내고 응답을 받지 않는다. 따라서 브로커의 상태에 상관없이 응답을 받기 때문에 메시지가 유실될 수 있다.
* acks=1
  * 메시지 전송 과정에서 응답을 받고, 리더 레플리카가 중단되면 메시지가 유실될 수 있다.
* acks=all
  * ISR에 포함된 레플리카들이 모두 메시지를 복제하면 응답을 받는다. 이 경우, 메시지가 유실될 가능성은 낮아진다.

### 7.4.2 프로듀서 재시도 설정하기

* 프로듀서 에러는 프로듀서가 자동으로 처리해주는 에러와 프로듀서 라이브러리를 사용하는 개발자들이 처리해야하는 에러로 나뉜다.
* 프로듀서는 재시도 가능한 에러는 자동으로 처리해준다. 하지만, 재시도가 무한정이라면 브로커에 부하를 줄 수 있기에 메시지 전송을 포기할 때까지 대기할 수 있는 시간을 지정해야 한다.

### 7.4.3 추가적인 에러 처리

* 개발자들이 처리해야하는 에러는 다음과 같다.
  * 메시지 크기에 관련되어 있거나 인가 관련 에러와 같이 재시도가 불가능한 에러
  * 메시지가 브로커에 전송되기 전에 발생한 에러
  * 프로듀서가 모든 재전송 시도를 소진했거나, 재시도 과정에서 프로듀서가 사용하는 가용 메모리가 메시지로 가득 차서 발생하는 에러
  * 타임아웃

## 7.5 신뢰성 있는 시스템에서 컨슈머 사용하기

* 컨슈머는 일관성이 보장되는 데이터만 읽는다. 또한 어디까지 읽었는지 추적한다.
* 컨슈머가 재시작하거나 새로 추가될 경우를 대비해서 컨슈머가 파티션에 대해 읽어온 오프셋을 커밋해둬야 한다.(__consumer_offset 토픽을 통해 오프셋을 관리한다.)
* 메시지를 처리하기 전에 커밋한다면, 데이터가 유실될 가능성이 있기 때문에 데이터 처리가 완료된 후 커밋해야한다.

### 7.5.1 신뢰성 있는 처리를 위해 중요한 컨슈머 설정

* 신뢰성을 갖는 컨슈머 설정을 위해 알아야할 속성은 다음과 같다.
  * group.id: 컨슈머 그룹의 식별자. 이를 통해 같은 그룹 내의 컨슈머들은 서로 다른 메시지를 소비한다.
  * auto.offset.reset: 컨슈머가 오프셋을 찾지 못했을 때 어떻게 처리할지 설정한다. (earliest, latest)
    * earliest: 파티션의 첫부분부터 읽기 시작한다.
    * latest: 파티션의 끝부분부터 읽기 시작한다. 즉, 일부 메시지가 누락될 수 있다.
  * enable.auto.commit: 컨슈머가 자동으로 오프셋을 커밋할지 설정한다. 일정 시간마다 커밋한다.
  * auto.commit.interval.ms: 컨슈머가 오프셋을 자동으로 커밋하는 주기를 설정한다.

### 7.5.2 컨슈머에서 명시적으로 오프셋 커밋하기

1. 메시지 처리 먼저, 오프셋 커밋은 나중에
    * 메시지 처리가 완료된 후에 오프셋을 커밋한다.
2. 커밋 빈도는 성능과 크래시 발생시 중복 개수 사이의 트레이드오프다
   * 커밋작업은 상당한 성능 오버헤드를 수반한다.
   * 커밋 주기는 성능과 중복 발생의 요구 조건 사이에서 균형을 맞춰야 한다.
3. 정확한 시점에 정확한 오프셋을 커밋하자
    * 언제나 처리가 완료된 메시지의 오프셋을 커밋하는 것이 중요하다.
4. 리밸런스
   * 컨슈머 그룹의 리밸런스가 발생하면, 컨슈머는 오프셋을 커밋해야한다.
5. 컨슈머는 재시도를 해야 할 수도 있다.
   * 컨슈머는 데이터 처리과정에서 메시지를 잃어버릴 수 있다. 이때, 컨슈머는 재시도를 해야한다.
   * 재시도 가능한 에러가 발생한 경우, 나중에 처리하기 위한 버퍼에 저장하며 pause()를 통해 poll()을 중지한다.
   * 재시도 가능한 경우 별도의 토픽에 쓴 뒤 계속 진행할 수 있다. 예를들면 DLQ(Dead Letter Queue)에 쓰는 것이다.
6. 컨슈머가 상태를 유지해야 할 수도 있다.
   * 상태를 유지해야한다면, 컨슈머는 데이터를 읽어온 후 데이터 처리 결과를 다시 카프카에 쓰는 작업을 진행하면 된다.

## 7.6 시스템 신뢰성 검증하기

### 7.6.1 설정 검증하기

* 애플리케이션 로직과 격리된 채 브로커와 클라이언트 설정을 검증하는 것은 쉬우며, 아래 같은 이유로 권장된다.
  * 현재 시스템이 요구 조건을 충족시킬 수 있는지 확인
  * 시스템의 예상 작동을 추론해 보기 위한 좋은 방법

### 7.6.2 애플리케이션 검증하기

* 브로커와 클라이언트의 설정이 요구 조건과 맞다는 것을 확인했다면, 애플리케이션이 필요로하는 요구조건을 보장하는지 확인해야한다.
* 다음과 같은 상황을 테스트해보는 것이 권장된다.
  * 클라이언트가 브로커 중 하나와 연결이 끊어짐
  * 클라이언트와 브로커 사이의 긴 지연
  * 디스크 꽉 참
  * 디스크 멈춤
  * 리더 선출
  * 브로커 롤링 재시작
  * 컨슈머 롤링 재시작
  * 프로듀서 롤링 재시작

### 7.6.3 프로덕션 환경에서 신뢰성 모니터링하기

* 프로듀서의 신뢰성 측면에서 가장 중요한 두 지표는 레코드별 에러율과 재시도율이다.
  * 레코드별 에러율: 전송된 레코드 중 에러가 발생한 레코드의 비율
  * 재시도율: 전송된 레코드 중 재시도가 발생한 레코드의 비율
* 컨슈머의 가장 중요한 지표는 컨슈머 랙이다.
  * 컨슈머가 브로커 내 파티션에 커밋된 가장 최신 메시지에서 얼마나 뒤처지는지를 나타낸다.