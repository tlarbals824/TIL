# 21장 메시지 큐를 이용한 비동기 통신

* 메시지 큐는 시스템의 컴포넌트가 서로 통신하는 새로운 방식입니다.
* 메시지 큐를 사용하면 컴포넌트끼리 직접 메시지를 주고받는 방식과 비교해 컴포넌트간의 결합을 느슨하게 하는 효과가 있습니다.
* 메시지 큐는 하나 혹은 여러 대상에 메시지를 전달할 수 있으며, 이를통해 시스템 아키텍처에 큰 유연성을 부여할수 있습니다.

## 21.1 비동기 메시징이란?

* 소프트웨어의 컴포넌트는 대개 동기적으로 통신합니다.
* 비동기 통신을 적용하면 클라이언트와 서버 사이에 계층이 하나 추가됩니다. 클라이언트가 서버에 요청할 것이 생기면, 서버에 직접 요청을 보내는 대신 큐에 요청을 보냅니다. 
서버는 큐를 주시하다 메시지를 수신하고 처리합니다. 이때 처리한 데이터를 큐로 보냅니다. 클라이언트가 응답을 필요로 하는 상태라면 큐를 주시하며 서버가 보낸 메시지를 수신합니다.
* 비동기 통신은 서버가 다운되더라도 클라이언트가 요청을 보낼 수 있으며 해당 요청이 유실되지 않습니다.
* 통합 아키텍처를 설계할 때 메시징은 중요합니다. 하지만 이에는 몇 가지 문제가 있습니다.
  * 큐를 제공하는 기술의 신뢰성이 매우 뛰어나야 합니다.
  * 큐 기술의 사용료가 비싸기에 개발 환경 또는 테스트 환경에서 큐 자체를 생략해야 한다는 문제가 있습니다.
* 앞선 문제를 도커의 오픈 소스 큐 시스템을 도입하여 해결할 수 있습니다.
* 메시지 큐는 일반적으로 고도로 최적화된 전용 통신 프로토콜을 가지고 있습니다. 이 프로토콜에 따라 클라이언트는 메시지를 보낸 후 큐의 수신 확인을 기다립니다.
* 메시지 큐 시스템은 메시지에 복잡한 가공을 하지 않으므로 어렵지 않게 초당 수천 건의 메시지를 처리할 수 있습니다.
* 메시지 큐 환경에서 모든 컴포넌트는 메시지 큐의 클라이언트가 됩니다.
* 메시지를 보내는 컴포넌트는 퍼블리셔(publisher)가 되고, 메시지를 받는 컴포넌트는 서브스크라이버(subscriber)가 됩니다.
* 다양한 시스템이 메시지 큐를 이용할 수 있으므로 채널(channel)을 나눠 메시지를 구분합니다.
* 퍼블리셔는 서브스크라이버가 큐를 주시하기 전부터 메시지를 보낼 수 있으며, 서브스크라이버는 퍼블리셔가 없더라도 큐를 주시할 수 있습니다.
* 메시지 큐를 다루는 컴포넌트는 같은 큐에서 메시지를 보내거나 받는 다른 컴포넌트의 존재를 알 수 없습니다.

## 21.2 클라우드 네이티브 메시지 큐 사용하기

* NATS에는 앞선 redis에서 사용한 채널 개념이 없습니다. 그 대신 모든 메시지에는 서브젝트(subject)가 부여됩니다.
* 이 서브젝트를 통해 메시지의 유형을 구분하며, 서브젝트에 원하는 명명 규칙을 적용할 수 있습니다.
* 서브스크라이버는 각자 자신이 관심 있는 주제가 부여된 메시지를 수신합니다. 이때, 서브스크라이버가 없더라도 애플리케이션은 계속 이 서브젝트로 메시지를 전달합니다.
* 메시지 큐에서 메시지를 수신하는 서브스크라이버가 없을 때의 처리 방법은 다음과 같습니다.
  * 관리자가 대신 처리할 수 있도록 데드-레터 큐(Dead-Letter Queue)에 메시지를 보관합니다.
  * 해당 큐에 서브스크라이버가 생길 때까지 메시지를 저장해 두는 방법을 사용하기도 합니다.
  * Redis와 NATS는 메시지를 수신할 서브스크라이버가 없다면 해당 메시지를 버립니다.

## 21.3 메시지 수신 및 처리

* 큐를 구독하는 컴포넌트를 메시지 핸들러라고 합니다.
* 메시지의 종류마다 이를 처리하는 메시지 헨들러가 하나씩 필요합니다.
* 비동기 메시징에서 발생하는 부수 효과를 결과적 일관성(eventual consistency)라고 합니다.
* 모든 메시지의 처리가 끝나면 애플리케이션 데이터의 상태가 정확해지는데, 그 이전 시점에는 일관성이 깨질 수 있습니다.
* 메시지 헨들러는 특정 목적에 특화된 작은 컴포넌트로, 주 애플리케이션아니 다른 컴포넌트와 별도로 업데이트하거나 스케일링할 수 있습니다.
* 메시지 헨들러를 추가하는 전략을 통해 애플리케이션 처리량을 늘릴 수 있습니다.

## 21.4 메시지 헨들러로 기능 추가하기

* 이벤트 지향 아키텍처는 애플리케이션이 모든 일을 즉각 동기적으로 처리하는 대신 이벤트를 통해 다른 구성 요소에 자신의 현재 상태를 알리는 방식을 말하며, 
이벤트를 발행하는 로직을 변경하지 않고도 이벤트 처리 로직을 바꿀 수 있으므로 애플리케이션의 구성 요소 간 결합도를 느슨하게 하는 효과가 있습니다.
* 새 기능을 추가하는 가장 쉬운 방법은 새로운 메시지 핸들러 그룹을 만들고 모든 메시지를 수신하도록 하되 이벤트 처리를 다르게 하는 것입니다.
* 애플리케이션에서 핵심 이벤트를 메시지 큐에 발행하기만 하면, 기존 컴포넌트를 수정하지 않고도 새로운 기능을 추가할 수 있습니다. 
또한 기존 애플리케이션에 영향을 미치지 않고 문제가 생긴다면 해당 메시지 핸들러만 중단시키면 됩니다.

## 21.5 비동기 메시징 패턴 이해하기

* 비동기 메시징을 도커를 통해 쉽게 구현할 수 있습니다.
* 메시지 큐에 메시지를 전달하고 수신하는 방법으로 퍼블리시-서브스크라이브(publish-subscribe) 패턴이 있습니다.
* 퍼블리시-서브스크라이브 패턴은 서브스크라이버(하나 이상이거나 없을 수 있음)가 퍼블리시된 메시지를 구독하는 형태입니다.
* 퍼블리시-서브스크라이브 패턴이 적합하지 않은 경우도 있습니다. 이는 퍼블리셔가 메시지를 사용하는 것이 누구고, 어떻게 처리하며, 언제 처리가 끝나는지 알 수 없습니다.
* 퍼블리셔의 불투명성을 리퀘스트-리스폰스(request-response) 패턴으로 해결할 수 있습니다.
* 리퀘스트-리스폰스(request-response)는 클라이언트가 메시지 큐에 메시지를 전달하고 응답을 기다립니다. 핸들러는 요청 메시지를 처리하고 응답 메시지를 메시지 큐에 보내며, 
큐는 다시 이 메시지를 클라이언트에 전달합니다.
* 대부분의 메시지 큐 기술은 앞선 패턴과 그 변종을 모두 지원합니다.
* 메시지 큐 기술은 애플리케이션 아키텍처가 운신할 폭을 크게 넓혀 줍니다.