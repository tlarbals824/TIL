# 6장

Pod를 특정 노드에 배치하거나 제한하는 스케줄링 제어 방법

```
                    Scheduler
                       │
    ┌──────────────────┼──────────────────┐
    ▼                  ▼                  ▼
 Node A             Node B             Node C
 (GPU)              (SSD)              (일반)
```

## 경계선(cordon)

노드를 스케줄링 대상에서 제외 (기존 Pod는 유지)

```
kubectl cordon node-1

Node: node-1
 ├─ Pod A (기존 - 유지)
 ├─ Pod B (기존 - 유지)
 └─ 새 Pod X (스케줄링 불가)
```

**동작**
- 노드에 `node.kubernetes.io/unschedulable` taint 추가
- 새 Pod는 해당 노드에 스케줄되지 않음
- 기존 실행 중인 Pod는 영향 없음

**사용 예**
- 노드 점검/유지보수 준비
- 문제 있는 노드를 격리하면서 기존 워크로드는 유지
- drain 전 사전 작업

```bash
# cordon 설정
kubectl cordon node-1

# 상태 확인 (SchedulingDisabled 표시)
kubectl get nodes

# cordon 해제
kubectl uncordon node-1
```

## 드레인(drain)

노드에서 모든 Pod를 안전하게 퇴거시킴 (cordon + evict)

```
kubectl drain node-1

Before:                    After:
Node-1                     Node-1 (비어있음)
 ├─ Pod A ─────────────→   Node-2: Pod A
 └─ Pod B ─────────────→   Node-3: Pod B
```

**동작**
1. 노드를 cordon 처리 (새 스케줄링 차단)
2. 노드의 모든 Pod를 다른 노드로 evict
3. DaemonSet Pod는 기본적으로 무시

**주요 옵션**
| 옵션 | 설명 |
| --- | --- |
| `--ignore-daemonsets` | DaemonSet Pod 무시 (필수) |
| `--delete-emptydir-data` | emptyDir 데이터 삭제 허용 |
| `--force` | ReplicaSet 없는 Pod도 강제 삭제 |
| `--grace-period` | 종료 유예 시간 (초) |

**사용 예**
- 노드 OS 업그레이드/재부팅
- 노드 교체 (scale down)
- 클러스터 버전 업그레이드

```bash
# 일반적인 drain
kubectl drain node-1 --ignore-daemonsets --delete-emptydir-data

# 강제 drain (standalone Pod 포함)
kubectl drain node-1 --ignore-daemonsets --force

# drain 후 복구
kubectl uncordon node-1
```

**주의사항**
- PodDisruptionBudget(PDB)이 설정되어 있으면 최소 가용성 보장
- StatefulSet Pod는 순서대로 종료됨
- Local storage가 있는 Pod는 `--delete-emptydir-data` 필요

## 노드이름(nodeName)

Pod를 특정 노드에 직접 지정 (스케줄러 우회)

```
Pod spec:
  nodeName: node-1

Scheduler (건너뜀) ─X─→ 직접 node-1에 배치
```

**특징**
- 스케줄러를 완전히 우회
- 노드가 없거나 리소스 부족해도 시도 (실패할 수 있음)
- 가장 단순하지만 유연성 없음

**사용 예**
- 디버깅/테스트 목적으로 특정 노드 지정
- DaemonSet 내부 구현 (자동으로 nodeName 설정됨)
- 스케줄러 없이 동작해야 하는 특수 상황

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-specific-node
spec:
  nodeName: node-1  # 직접 노드 지정
  containers:
    - name: nginx
      image: nginx
```

**주의사항**
- 노드 이름 하드코딩으로 이식성 떨어짐
- 프로덕션에서는 nodeSelector/affinity 권장

## 노드 레이블(label)

노드에 메타데이터를 부여하여 분류/선택에 활용

```
Node-1                    Node-2                    Node-3
 labels:                   labels:                   labels:
  disktype: ssd            disktype: hdd             disktype: ssd
  gpu: true                gpu: false                gpu: false
  zone: ap-1               zone: ap-1                zone: ap-2
```

**기본 제공 레이블**
| 레이블 | 설명 |
| --- | --- |
| `kubernetes.io/hostname` | 노드 호스트명 |
| `kubernetes.io/os` | OS (linux/windows) |
| `kubernetes.io/arch` | 아키텍처 (amd64/arm64) |
| `topology.kubernetes.io/zone` | 가용영역 |
| `topology.kubernetes.io/region` | 리전 |
| `node.kubernetes.io/instance-type` | 인스턴스 타입 (클라우드) |

**레이블 관리**
```bash
# 레이블 추가
kubectl label nodes node-1 disktype=ssd

# 레이블 확인
kubectl get nodes --show-labels
kubectl get nodes -L disktype,gpu

# 레이블 수정
kubectl label nodes node-1 disktype=hdd --overwrite

# 레이블 삭제
kubectl label nodes node-1 disktype-
```

## 노드셀렉터(nodeSelector)

레이블 기반으로 Pod를 특정 노드 그룹에 스케줄링

```
Pod (nodeSelector: disktype=ssd)
         │
         ▼
    ┌────┴────┐
    ▼         ▼
  Node-1    Node-3   (disktype=ssd인 노드만)
```

**특징**
- 가장 단순한 노드 선택 방법
- AND 조건으로 동작 (모든 레이블 일치해야 함)
- 일치하는 노드 없으면 Pending 상태

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: ssd-pod
spec:
  nodeSelector:
    disktype: ssd
    zone: ap-1
  containers:
    - name: app
      image: nginx
```

**사용 예**
- GPU 워크로드를 GPU 노드에만 배치
- SSD가 필요한 DB를 SSD 노드에 배치
- 특정 가용영역에 Pod 배치

## 노드 어피니티(affinity), 안티어피니티(anti-affinity)

nodeSelector의 확장판으로 더 유연한 조건 표현 가능

```
Node Affinity:
  "disktype=ssd인 노드 선호 (필수는 아님)"
  "zone이 ap-1 또는 ap-2인 노드에만 배치"

Pod Anti-Affinity:
  "같은 app=web인 Pod가 있는 노드 피하기"
```

**노드 어피니티 타입**
| 타입 | 설명 |
| --- | --- |
| `requiredDuringSchedulingIgnoredDuringExecution` | 필수 조건 (hard) - 만족 안하면 스케줄 안됨 |
| `preferredDuringSchedulingIgnoredDuringExecution` | 선호 조건 (soft) - 가능하면 만족하는 노드 선택 |

**연산자**
| 연산자 | 설명 | 예시 |
| --- | --- | --- |
| `In` | 값 목록 중 하나 | zone In [ap-1, ap-2] |
| `NotIn` | 값 목록에 없음 | env NotIn [prod] |
| `Exists` | 키만 존재하면 됨 | gpu Exists |
| `DoesNotExist` | 키가 없어야 함 | gpu DoesNotExist |
| `Gt` | 값보다 큼 | cpu-cores Gt 4 |
| `Lt` | 값보다 작음 | cpu-cores Lt 8 |

**노드 어피니티 예시 (필수)**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: node-affinity-required
spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
              - key: disktype
                operator: In
                values:
                  - ssd
                  - nvme
  containers:
    - name: app
      image: nginx
```

**노드 어피니티 예시 (선호)**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: node-affinity-preferred
spec:
  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 80
          preference:
            matchExpressions:
              - key: zone
                operator: In
                values:
                  - ap-northeast-2a
        - weight: 20
          preference:
            matchExpressions:
              - key: disktype
                operator: In
                values:
                  - ssd
  containers:
    - name: app
      image: nginx
```

**Pod 안티어피니티 (분산 배치)**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchLabels:
                  app: web
              topologyKey: kubernetes.io/hostname  # 노드별로 분산
      containers:
        - name: nginx
          image: nginx
```

**topologyKey**
- `kubernetes.io/hostname`: 노드 단위 분산
- `topology.kubernetes.io/zone`: 가용영역 단위 분산
- `topology.kubernetes.io/region`: 리전 단위 분산

**사용 예**
- HA를 위해 replica를 서로 다른 노드/zone에 분산
- 특정 노드 타입 선호하되 없으면 다른 노드도 허용
- DB와 캐시를 같은 zone에 배치 (podAffinity)

## 테인트(taint)와 톨러레이션(toleration)

노드가 특정 Pod를 거부하거나 허용하는 메커니즘

```
Node (taint: gpu=true:NoSchedule)
         │
         ├─ Pod A (toleration 없음) ──→ 거부됨
         └─ Pod B (toleration 있음) ──→ 허용됨
```

**taint vs affinity 차이**
- Affinity: Pod가 노드를 **선택**
- Taint: 노드가 Pod를 **거부**

**Taint Effect 종류**
| Effect | 설명 |
| --- | --- |
| `NoSchedule` | toleration 없으면 스케줄 안됨 (기존 Pod 유지) |
| `PreferNoSchedule` | 가능하면 스케줄 안함 (soft) |
| `NoExecute` | toleration 없으면 스케줄 안됨 + 기존 Pod도 퇴거 |

**Taint 관리**
```bash
# taint 추가
kubectl taint nodes node-1 gpu=true:NoSchedule

# taint 확인
kubectl describe node node-1 | grep Taints

# taint 제거
kubectl taint nodes node-1 gpu=true:NoSchedule-
```

**Toleration 예시**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: gpu-pod
spec:
  tolerations:
    - key: "gpu"
      operator: "Equal"
      value: "true"
      effect: "NoSchedule"
  containers:
    - name: cuda-app
      image: nvidia/cuda
```

**Toleration 연산자**
| operator | 설명 |
| --- | --- |
| `Equal` | key, value, effect 모두 일치 |
| `Exists` | key만 일치하면 됨 (value 무시) |

**모든 taint 허용 (DaemonSet 패턴)**
```yaml
tolerations:
  - operator: "Exists"  # 모든 taint 허용
```

**NoExecute + tolerationSeconds**
```yaml
tolerations:
  - key: "node.kubernetes.io/unreachable"
    operator: "Exists"
    effect: "NoExecute"
    tolerationSeconds: 300  # 5분 후 퇴거
```

**기본 시스템 Taint**
| Taint | 설명 |
| --- | --- |
| `node.kubernetes.io/not-ready` | 노드가 Ready 아님 |
| `node.kubernetes.io/unreachable` | 노드에 연결 불가 |
| `node.kubernetes.io/memory-pressure` | 메모리 부족 |
| `node.kubernetes.io/disk-pressure` | 디스크 부족 |
| `node.kubernetes.io/unschedulable` | cordon 상태 |

**사용 예**
- GPU/전용 노드를 특정 워크로드만 사용하도록 제한
- Master 노드에 일반 Pod 스케줄 방지
- 문제 노드에서 Pod 자동 퇴거 (NoExecute)
- 노드 점검 시 점진적 퇴거 (tolerationSeconds 활용)

## 스케줄링 전략 요약

| 방법 | 주체 | 유연성 | 사용 시나리오 |
| --- | --- | --- | --- |
| nodeName | Pod | 없음 | 디버깅, 테스트 |
| nodeSelector | Pod | 낮음 | 단순한 노드 그룹 선택 |
| Node Affinity | Pod | 높음 | 복잡한 조건, soft/hard 구분 |
| Pod Affinity/Anti-Affinity | Pod | 높음 | Pod 간 분산/집중 배치 |
| Taint/Toleration | Node | 높음 | 노드를 특정 용도로 격리 |

**조합 예시: GPU 전용 노드**
```bash
# 1. GPU 노드에 레이블 + taint
kubectl label nodes gpu-node-1 gpu=true
kubectl taint nodes gpu-node-1 gpu=true:NoSchedule
```

```yaml
# 2. GPU Pod에 nodeSelector + toleration
apiVersion: v1
kind: Pod
metadata:
  name: ml-training
spec:
  nodeSelector:
    gpu: "true"
  tolerations:
    - key: "gpu"
      operator: "Equal"
      value: "true"
      effect: "NoSchedule"
  containers:
    - name: training
      image: tensorflow/tensorflow:latest-gpu
```
