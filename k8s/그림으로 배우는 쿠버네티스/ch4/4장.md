# 4장 - Service

Service는 Pod들에 대한 안정적인 네트워크 접근점을 제공하는 리소스

```
Service
 └─ 고정 IP/DNS ─→ 여러 Pod들 (동적으로 변경됨)
```

**왜 Service가 필요한가?**
- Pod은 생성/삭제될 때마다 IP가 바뀜
- Service는 고정된 IP와 DNS를 제공
- 로드밸런싱으로 여러 Pod에 트래픽 분산

```
              ┌─────────────────────────────────────┐
              │            Kubernetes Cluster        │
              │                                      │
외부 요청 ──→ │  Service (고정 IP)                   │
              │      │                               │
              │      ├──→ Pod A (10.0.0.5)          │
              │      ├──→ Pod B (10.0.0.6)          │
              │      └──→ Pod C (10.0.0.7)          │
              └─────────────────────────────────────┘
```

## Port-forward

로컬 머신의 포트를 클러스터 내부 Pod으로 직접 연결

```
로컬:8080 ───────→ Pod:80
```

```bash
# Pod에 직접 포트포워딩
kubectl port-forward pod/nginx-pod 8080:80

# Service를 통한 포트포워딩
kubectl port-forward svc/nginx-svc 8080:80
```

**특징**
- 개발/디버깅 용도로만 사용
- kubectl 프로세스가 종료되면 연결 끊김
- 상용 환경에서는 사용하지 않음

## hostPort, hostNetwork

노드의 네트워크를 직접 사용하는 방식

**hostPort**
```yaml
spec:
  containers:
    - name: nginx
      ports:
        - containerPort: 80
          hostPort: 8080    # 노드의 8080 포트와 직접 바인딩
```

**hostNetwork**
```yaml
spec:
  hostNetwork: true         # Pod이 노드의 네트워크 네임스페이스 사용
  containers:
    - name: nginx
```

```
hostPort:    노드:8080 ──→ Pod:80
hostNetwork: Pod이 노드 IP 직접 사용
```

**사용하지 않는 이유**
- 포트 충돌 위험 (같은 노드에 같은 포트 사용 불가)
- 보안상 문제 (Pod이 노드 네트워크에 직접 노출)
- 스케줄링 제약 (특정 포트가 사용 중인 노드에 배포 불가)

## NodePort

모든 노드의 특정 포트를 열어 외부에서 접근 가능하게 하는 Service

```
외부 ──→ 노드IP:30080 ──→ Service ──→ Pod
```

```yaml
apiVersion: v1
kind: Service
metadata:
  name: nodeport-svc
spec:
  type: NodePort
  selector:
    app: nginx
  ports:
    - port: 80          # Service 포트 (클러스터 내부)
      targetPort: 80    # Pod 포트
      nodePort: 30080   # 노드 포트 (30000-32767, 생략시 자동 할당)
```

```
┌─────────────────────────────────────────────┐
│              Kubernetes Cluster              │
│                                              │
│  Node 1 (:30080)    Node 2 (:30080)         │
│       │                   │                  │
│       └───────┬───────────┘                  │
│               ▼                              │
│           Service                            │
│               │                              │
│       ┌───────┼───────┐                      │
│       ▼       ▼       ▼                      │
│     Pod A   Pod B   Pod C                    │
└─────────────────────────────────────────────┘
```

**특징**
- 모든 노드에서 동일한 포트로 접근 가능
- 포트 범위: 30000-32767
- 외부 로드밸런서 없이 간단히 외부 노출 가능
- 노드 IP가 변경되면 접근 불가 (프로덕션에서는 LoadBalancer 권장)

## LoadBalancer

클라우드 제공자의 로드밸런서와 연동하여 외부 IP 자동 할당

```
외부 ──→ 로드밸런서(External IP) ──→ NodePort ──→ Service ──→ Pod
```

```yaml
apiVersion: v1
kind: Service
metadata:
  name: loadbalancer-svc
spec:
  type: LoadBalancer
  selector:
    app: nginx
  ports:
    - port: 80
      targetPort: 80
```

```
┌────────────────────────────────────────────────────┐
│                 Cloud Provider                      │
│  ┌──────────────────────────────────────────────┐  │
│  │          Load Balancer (외부 IP 할당)         │  │
│  └──────────────────┬───────────────────────────┘  │
│                     ▼                               │
│  ┌──────────────────────────────────────────────┐  │
│  │           Kubernetes Cluster                  │  │
│  │                                               │  │
│  │    Node 1 (:30080)    Node 2 (:30080)        │  │
│  │         │                   │                 │  │
│  │         └───────┬───────────┘                 │  │
│  │                 ▼                             │  │
│  │             Service                           │  │
│  │                 │                             │  │
│  │         ┌───────┼───────┐                     │  │
│  │         ▼       ▼       ▼                     │  │
│  │       Pod A   Pod B   Pod C                   │  │
│  └──────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────┘
```

**동작 방식**
1. LoadBalancer Service 생성
2. 클라우드 컨트롤러가 감지
3. 클라우드 로드밸런서 자동 생성
4. 외부 IP 할당

```bash
> kubectl get svc
NAME               TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)
loadbalancer-svc   LoadBalancer   10.96.100.50    34.123.45.67    80:31234/TCP
```

**특징**
- 클라우드 환경에서만 사용 가능 (AWS, GCP, Azure 등)
- 외부 IP가 자동으로 할당됨
- 내부적으로 NodePort를 생성함
- 로컬 환경에서는 MetalLB 등 별도 설정 필요

## ExternalName

클러스터 내부에서 외부 서비스를 DNS 이름으로 접근

```
Pod ──→ Service(DNS) ──→ 외부 도메인
```

```yaml
apiVersion: v1
kind: Service
metadata:
  name: external-db
spec:
  type: ExternalName
  externalName: database.example.com   # 외부 DNS 이름
```

```
┌─────────────────────────────────────┐
│         Kubernetes Cluster           │
│                                      │
│  Pod ──→ external-db (Service)       │
│                │                     │
│                │ CNAME               │
└────────────────┼─────────────────────┘
                 ▼
         database.example.com (외부)
```

**사용 예시**
```bash
# Pod 내부에서
curl http://external-db   # → database.example.com으로 연결
```

**특징**
- ClusterIP가 할당되지 않음
- 단순히 DNS CNAME 레코드 역할
- 외부 서비스 주소를 추상화할 때 유용
- 마이그레이션 시 서비스 이름 유지 가능

## ClusterIP

클러스터 내부에서만 접근 가능한 기본 Service 타입

```
Pod A ──→ ClusterIP ──→ Pod B
(클러스터 내부 통신만 가능)
```

```yaml
apiVersion: v1
kind: Service
metadata:
  name: clusterip-svc
spec:
  type: ClusterIP        # 기본값, 생략 가능
  selector:
    app: nginx
  ports:
    - port: 80
      targetPort: 80
```

```
┌─────────────────────────────────────┐
│         Kubernetes Cluster           │
│                                      │
│  Frontend Pod                        │
│       │                              │
│       ▼                              │
│  ClusterIP Service (10.96.0.100)     │
│       │                              │
│       ├──→ Backend Pod 1             │
│       ├──→ Backend Pod 2             │
│       └──→ Backend Pod 3             │
│                                      │
│  (외부에서 접근 불가)                 │
└─────────────────────────────────────┘
```

## Headless Service

ClusterIP가 없는 Service (clusterIP: None)

```yaml
apiVersion: v1
kind: Service
metadata:
  name: headless-svc
spec:
  clusterIP: None        # Headless 설정
  selector:
    app: nginx
  ports:
    - port: 80
      targetPort: 80
```

**ClusterIP vs Headless**

| 특징 | ClusterIP | Headless |
| --- | --- | --- |
| Service IP | 할당됨 (10.96.x.x) | 없음 (None) |
| DNS 응답 | Service IP 반환 | Pod IP들 직접 반환 |
| 로드밸런싱 | Service가 수행 | 클라이언트가 선택 |
| 용도 | 일반적인 서비스 | StatefulSet, 직접 Pod 접근 |

```
ClusterIP:
  nslookup clusterip-svc
  → 10.96.0.100 (Service IP)

Headless:
  nslookup headless-svc
  → 10.0.0.5 (Pod A IP)
  → 10.0.0.6 (Pod B IP)
  → 10.0.0.7 (Pod C IP)
```

**특징**
- IP를 소진하지 않음
- 도메인 이름만으로 Pod에 직접 접근
- StatefulSet과 함께 사용하여 개별 Pod 접근 가능
  - `pod-0.headless-svc.namespace.svc.cluster.local`

## Endpoint

Service가 트래픽을 전달할 실제 Pod IP 목록

```
Service ──→ Endpoints ──→ Pod IPs
```

```bash
# Endpoint 확인
> kubectl get endpoints nginx-svc
NAME        ENDPOINTS
nginx-svc   10.0.0.5:80,10.0.0.6:80,10.0.0.7:80
```

**동작 방식**
```
┌─────────────────────────────────────────────────┐
│                                                  │
│  Service (selector: app=nginx)                  │
│       │                                          │
│       ▼                                          │
│  Endpoints (자동 생성/관리)                      │
│       │                                          │
│       ├──→ 10.0.0.5:80 (Pod A, app=nginx)       │
│       ├──→ 10.0.0.6:80 (Pod B, app=nginx)       │
│       └──→ 10.0.0.7:80 (Pod C, app=nginx)       │
│                                                  │
└─────────────────────────────────────────────────┘
```

**수동 Endpoint 설정**

selector 없이 Service를 만들고 Endpoint를 직접 지정할 수 있음

```yaml
# Service (selector 없음)
apiVersion: v1
kind: Service
metadata:
  name: external-svc
spec:
  ports:
    - port: 80
---
# Endpoint 수동 생성
apiVersion: v1
kind: Endpoints
metadata:
  name: external-svc    # Service 이름과 동일해야 함
subsets:
  - addresses:
      - ip: 192.168.1.100   # 외부 서버 IP
      - ip: 192.168.1.101
    ports:
      - port: 80
```

**용도**
- 클러스터 외부 서비스 연결
- 레거시 시스템 통합
- 마이그레이션 과정에서 활용

## Ingress

HTTP/HTTPS 트래픽을 클러스터 내부 Service로 라우팅하는 L7 로드밸런서

```
외부 ──→ Ingress (도메인/경로 기반 라우팅) ──→ Service ──→ Pod
```

**왜 Ingress가 필요한가?**
- LoadBalancer는 Service마다 외부 IP가 필요 (비용 증가)
- Ingress는 하나의 IP로 여러 Service에 라우팅 가능
- 도메인/경로 기반 라우팅, SSL 종료 등 L7 기능 제공

```
┌─────────────────────────────────────────────────────────────┐
│                    Kubernetes Cluster                        │
│                                                              │
│   외부 요청                                                  │
│       │                                                      │
│       ▼                                                      │
│   Ingress Controller (nginx, traefik 등)                    │
│       │                                                      │
│       ├── api.example.com ──→ api-svc ──→ API Pods          │
│       ├── web.example.com ──→ web-svc ──→ Web Pods          │
│       └── example.com/admin ──→ admin-svc ──→ Admin Pods    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**Ingress vs LoadBalancer**

| 특징 | LoadBalancer | Ingress |
| --- | --- | --- |
| 계층 | L4 (TCP/UDP) | L7 (HTTP/HTTPS) |
| 외부 IP | Service마다 1개 | 전체에서 1개 |
| 라우팅 | IP:Port 기반 | 도메인/경로 기반 |
| SSL 종료 | 별도 설정 | 기본 지원 |
| 비용 | 높음 (IP당 과금) | 낮음 |

### Ingress Controller

Ingress 리소스를 실제로 처리하는 컴포넌트 (별도 설치 필요)

```
Ingress (규칙 정의) ←── 감시 ──→ Ingress Controller (실제 처리)
```

**주요 Ingress Controller**
- **NGINX Ingress Controller**: 가장 널리 사용
- **Traefik**: 자동 설정, Let's Encrypt 연동
- **AWS ALB Ingress Controller**: AWS 환경
- **GCE Ingress Controller**: GCP 환경

```bash
# NGINX Ingress Controller 설치 (예시)
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.0/deploy/static/provider/cloud/deploy.yaml
```

### 기본 Ingress 설정

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: simple-ingress
spec:
  ingressClassName: nginx    # 사용할 Ingress Controller
  rules:
    - host: example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: web-svc
                port:
                  number: 80
```

### 도메인 기반 라우팅

여러 도메인을 각각 다른 Service로 라우팅

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: domain-ingress
spec:
  ingressClassName: nginx
  rules:
    - host: api.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: api-svc
                port:
                  number: 80
    - host: web.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: web-svc
                port:
                  number: 80
```

```
api.example.com ──→ api-svc
web.example.com ──→ web-svc
```

### 경로 기반 라우팅

하나의 도메인에서 경로별로 다른 Service로 라우팅

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: path-ingress
spec:
  ingressClassName: nginx
  rules:
    - host: example.com
      http:
        paths:
          - path: /api
            pathType: Prefix
            backend:
              service:
                name: api-svc
                port:
                  number: 80
          - path: /admin
            pathType: Prefix
            backend:
              service:
                name: admin-svc
                port:
                  number: 80
          - path: /
            pathType: Prefix
            backend:
              service:
                name: web-svc
                port:
                  number: 80
```

```
example.com/api/*   ──→ api-svc
example.com/admin/* ──→ admin-svc
example.com/*       ──→ web-svc
```

**pathType 종류**
- `Prefix`: 경로 접두사 매칭 (`/api`는 `/api`, `/api/users` 모두 매칭)
- `Exact`: 정확히 일치하는 경로만 매칭
- `ImplementationSpecific`: Controller 구현에 따름

### TLS/SSL 설정

HTTPS 트래픽 처리를 위한 인증서 설정

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: tls-ingress
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - example.com
      secretName: example-tls    # TLS 인증서가 저장된 Secret
  rules:
    - host: example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: web-svc
                port:
                  number: 80
```

```bash
# TLS Secret 생성
kubectl create secret tls example-tls \
  --cert=tls.crt \
  --key=tls.key
```

```
HTTPS 요청 ──→ Ingress (SSL 종료) ──→ HTTP ──→ Service ──→ Pod
```

### Ingress 확인

```bash
> kubectl get ingress
NAME             CLASS   HOSTS           ADDRESS        PORTS     AGE
simple-ingress   nginx   example.com     34.123.45.67   80, 443   1h

> kubectl describe ingress simple-ingress
Name:             simple-ingress
Rules:
  Host           Path  Backends
  ----           ----  --------
  example.com    /     web-svc:80 (10.0.0.5:80,10.0.0.6:80)
```

### 동작 흐름

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  1. 클라이언트 요청: https://api.example.com/users              │
│                          │                                       │
│                          ▼                                       │
│  2. DNS → Ingress Controller IP (34.123.45.67)                  │
│                          │                                       │
│                          ▼                                       │
│  3. Ingress Controller가 Ingress 규칙 확인                      │
│     - host: api.example.com ✓                                   │
│     - path: /users → Prefix "/" 매칭 ✓                          │
│                          │                                       │
│                          ▼                                       │
│  4. 매칭된 Service (api-svc)로 트래픽 전달                      │
│                          │                                       │
│                          ▼                                       │
│  5. Service가 Pod으로 로드밸런싱                                 │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**특징**
- L7 로드밸런서로 HTTP/HTTPS만 처리
- 하나의 외부 IP로 여러 서비스 노출 가능
- Ingress Controller 별도 설치 필요
- 도메인/경로 기반 라우팅, SSL 종료 지원
- TCP/UDP 트래픽은 처리 불가 (NodePort/LoadBalancer 사용)

## Service 타입 비교

| 타입 | 접근 범위 | 외부 IP | 용도 |
| --- | --- | --- | --- |
| ClusterIP | 클러스터 내부 | ❌ | 내부 서비스 간 통신 |
| NodePort | 노드IP:포트 | ❌ (노드 IP 사용) | 개발/테스트 |
| LoadBalancer | 외부 | ✅ (자동 할당) | 프로덕션 외부 노출 |
| ExternalName | 클러스터 내부→외부 | ❌ | 외부 서비스 참조 |
| Headless | 클러스터 내부 | ❌ | StatefulSet, 직접 Pod 접근 |

```
접근성 레벨:

ClusterIP:      [클러스터 내부만]
NodePort:       [클러스터 내부] + [노드 IP로 외부 접근]
LoadBalancer:   [클러스터 내부] + [외부 IP로 외부 접근]
ExternalName:   [내부 → 외부 DNS 연결]
Headless:       [클러스터 내부, Pod 직접 접근]
```
