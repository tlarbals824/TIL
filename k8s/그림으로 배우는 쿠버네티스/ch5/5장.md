# 5장

Pod의 파일시스템을 확장하고, 컨테이너 재시작/재배치에도 데이터를 유지하기 위한 스토리지 개념

## emptyDir

Pod가 노드에 스케줄될 때 생성되는 임시 디렉터리 (Pod 단위 공유)

```
Pod
 ├─ Container A ─┐
 │  /cache      │
 └─ Container B ─┘  (same emptyDir)
```

**특징**
- Pod 살아있는 동안만 유지 (Pod 삭제 시 데이터 소멸)
- 컨테이너 재시작에는 유지됨 (Pod는 그대로)
- 컨테이너 간 임시 데이터 공유에 적합
- `medium: Memory`로 메모리 기반 tmpfs 사용 가능

**사용 예**
- 애플리케이션 캐시/임시 파일 저장 (`/tmp`, `/cache`)
- initContainer가 만든 파일을 앱 컨테이너와 공유
- 사이드카와 로그/아티팩트 공유 (전송 전 임시 저장)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: emptydir-demo
spec:
  containers:
    - name: app
      image: docker.io/library/busybox
      command: ["sh", "-c", "echo hi > /cache/data && sleep 3600"]
      volumeMounts:
        - name: cache
          mountPath: /cache
  volumes:
    - name: cache
      emptyDir: {}
```

## hostPath

노드의 특정 경로를 Pod에 마운트하는 방식

```
Node FS (/var/log) ──→ Pod (/host-logs)
```

**특징**
- 노드에 종속 (다른 노드로 이동하면 데이터 없음)
- 보안 위험 (노드 파일 시스템 직접 접근)
- 주로 DaemonSet/로그 수집/노드 에이전트에 사용

**사용 예**
- 노드 로그 수집 에이전트 (`/var/log` 마운트)
- CNI/스토리지/모니터링 에이전트가 노드 리소스 접근 필요 시
- 개발/테스트에서 단순히 노드의 파일을 그대로 쓰고 싶을 때

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: hostpath-demo
spec:
  containers:
    - name: agent
      image: docker.io/library/busybox
      command: ["sh", "-c", "ls /host-logs && sleep 3600"]
      volumeMounts:
        - name: varlog
          mountPath: /host-logs
  volumes:
    - name: varlog
      hostPath:
        path: /var/log
        type: Directory
```

## NFS

네트워크 파일시스템을 통해 여러 노드/Pod에서 동일 스토리지를 공유

```
NFS Server (/export/data)
   ▲        ▲
   │        │
Pod A    Pod B   (서로 다른 노드여도 동일 데이터)
```

**특징**
- 여러 Pod에서 동시 읽기/쓰기 가능 (ReadWriteMany)
- 네트워크/서버 가용성에 의존
- 클라우드/온프레미스 모두 사용 가능

**사용 예**
- 여러 노드의 Pod가 동일 데이터를 공유해야 할 때 (공유 업로드, 모델/미디어 배포)
- 외부 NAS/스토리지 장비를 그대로 활용해야 할 때
- 간단한 파일 기반 공유가 필요할 때 (DB보다는 파일 저장소 성격)

**AccessModes별 용도**
| 모드 | NFS에서의 용도 | 사용 예 |
| --- | --- | --- |
| ReadWriteMany (RWX) | 일반적인 NFS 사용 패턴, 여러 Pod 동시 읽기/쓰기 | 공유 업로드 폴더, 공용 모델/미디어 디렉터리 |
| ReadOnlyMany (ROX) | 공통 설정/정적 자산 배포 (읽기 전용) | 설정 템플릿/정적 파일 배포, 읽기 전용 배포 아티팩트 |
| ReadWriteOnce (RWO) | 단일 Pod만 쓰도록 제한하고 싶을 때 | 단일 소비자만 허용하는 배치 작업, 단일 인스턴스 앱 |

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nfs-demo
spec:
  containers:
    - name: app
      image: docker.io/library/busybox
      command: ["sh", "-c", "touch /data/hello && sleep 3600"]
      volumeMounts:
        - name: nfs-vol
          mountPath: /data
  volumes:
    - name: nfs-vol
      nfs:
        server: 10.0.0.10
        path: /export/data
```

## Persistent Volume, Claim

Pod와 스토리지를 분리해 관리하는 방식

```
관리자               사용자
PV (실제 스토리지)  ←  PVC (요청)
        ▲               │
        └──── Pod ──────┘
```

**개념**
- **PV**: 클러스터 전체 스토리지 리소스 (관리자/프로비저너가 제공)
- **PVC**: 필요한 스토리지를 요청하는 리소스 (사용자)
- **바인딩**: PVC 조건에 맞는 PV가 자동 연결

**PV/PVC 관계**
- PV와 PVC는 1:1로 바인딩됨
- 여러 Pod가 같은 PVC를 공유하는 것은 가능 (accessModes에 따라)

**바인딩 조건**
- PV 용량 ≥ PVC 요청 용량
- PVC보다 큰 PV도 바인딩될 수 있으며, 남는 용량은 다른 PVC가 사용하지 못함
- accessModes 일치
- storageClassName 일치 (있을 경우)

**AccessModes**
| 모드 | 의미 |
| --- | --- |
| ReadWriteOnce (RWO) | 단일 노드에서 읽기/쓰기 |
| ReadOnlyMany (ROX) | 여러 노드에서 읽기 전용 |
| ReadWriteMany (RWX) | 여러 노드에서 읽기/쓰기 |
| ReadWriteOncePod (RWOP) | 단일 Pod에서만 읽기/쓰기 |

**사용 예**
- stateful app이 Pod 재시작/재배치에도 데이터를 유지해야 할 때
- 운영/개발 분리 없이 동일한 PVC 스펙으로 스토리지를 추상화할 때
- 팀 간 스토리지 제공자(PV)와 사용자(PVC)를 분리하고 싶을 때

**PV 예시 (정적 프로비저닝)**
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-nfs
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteMany
  storageClassName: nfs
  persistentVolumeReclaimPolicy: Retain
  nfs:
    server: 10.0.0.10
    path: /export/data
```

**PVC 예시**
```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-data
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 5Gi
  storageClassName: nfs
```

**Pod에서 사용**
```yaml
spec:
  containers:
    - name: app
      volumeMounts:
        - name: data
          mountPath: /data
  volumes:
    - name: data
      persistentVolumeClaim:
        claimName: pvc-data
```

## StorageClass

동적 프로비저닝을 위한 스토리지 템플릿

```
PVC ─→ StorageClass ─→ PV 자동 생성 ─→ Pod
```

**특징**
- PVC가 생성되면 필요한 PV를 자동 생성
- 스토리지 타입/성능 파라미터를 표준화
- 기본 StorageClass 지정 가능

**정적 vs 동적 프로비저닝**
- 정적(PV 선생성): PV 생성 → PVC가 조건에 맞는 PV에 바인딩
- 동적(StorageClass): PVC 생성 → StorageClass가 PV 자동 생성 → PVC에 바인딩

**언제 정적/동적을 쓰나**
- 정적: 스토리지 승인/검수가 필요한 환경, 특정 디스크를 수동 할당해야 할 때, 레거시/NFS 등 외부 스토리지를 그대로 쓸 때
- 동적: 팀이 셀프서비스로 PVC를 생성해야 할 때, dev/prod에서 표준화된 클래스로 빠르게 스토리지 생성할 때, 오버헤드를 줄이고 싶을 때

**사용 예**
- dev/prod에서 동일 PVC 스펙으로 서로 다른 스토리지 사용
- fast/slow 같은 성능 티어를 선택 가능하게 만들 때
- 동적 프로비저닝으로 운영 오버헤드를 줄이고 싶을 때

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp3
reclaimPolicy: Delete
volumeBindingMode: WaitForFirstConsumer
allowVolumeExpansion: true
```

## volumeClaimTemplates

StatefulSet에서 Pod마다 PVC를 자동 생성

```
StatefulSet
 ├─ pod-0 ─→ pvc/data-pod-0
 ├─ pod-1 ─→ pvc/data-pod-1
 └─ pod-2 ─→ pvc/data-pod-2
```

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
spec:
  serviceName: mysql-headless
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
        - name: mysql
          image: docker.io/library/mysql:8.0
          volumeMounts:
            - name: data
              mountPath: /var/lib/mysql
  volumeClaimTemplates:
    - metadata:
        name: data
      spec:
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: 10Gi
```

**특징**
- Pod 이름에 따라 PVC가 자동 생성/연결됨
- StatefulSet 삭제 시에도 PVC는 기본적으로 유지됨
- 데이터베이스/메시지 큐 등 상태 저장 앱에 필수

**사용 예**
- DB/큐처럼 레플리카마다 독립 데이터가 필요한 경우
- 샤딩/파티셔닝 구조에서 Pod별 고정 스토리지가 필요할 때
