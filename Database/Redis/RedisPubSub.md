# Redis pub/sub

* Redis는 아주 가벼운 pub/sub 기능을 제공합니다.
* Redis 노드에 집근할 수 있는 모든 클라이언트는 발행자와 구독자가 될 수 있습니다.
* 발행자는 특정 채널에 메시지를 보낼 수 있으며, 구독자는 특정 채널을 듣고있다가 메시지를 읽어갈 수 있습니다.
* Redis의 pub/sub은 최소한의 메시지 전달 기능만 제공합니다. 
* 발행자는 메시지를 채널로 보낼 수 있을 뿐, 어떤 구독자가 메시지를 읽어가는지, 정상적으로 모든 구독자에게 메시지가 전달됐는지 확인할 수 없습니다.
* 구독자는 메시지를 받을 수 있지만 해당 메시지가 언제 어떤 발행자에 의해 생성됐는지 등의 메타데이터는 알 수 없습니다.
* 한 번 전파된 데이터는 레디스에 저장되지 않습니다. 이로인해 정합성이 중요한 데이터를 전달하기에는 적합하지 않을 수 있습니다.

## 메시지 publish 하기

* Redis에서는 PUBLISH 명령어를 통해 메시지를 발행할 수 있습니다.

~~~
> PUBLISH <channel> <message>
(integer) <number>
~~~

* channel은 메시지를 발행할 채널을 의미하며, message는 발행할 메시지를 의미합니다.
* number는 메시지를 받는 구독자의 수를 의미합니다.

## 메시지 subscribe 하기

* Redis에서는 SUBSCRIBE 명령어를 통해 메시지를 구독할 수 있습니다.

~~~
> SUBSCRIBE <channel> [<channel> ...]
1) "subscribe"
2) "<channel>"
3) (integer) <number>
1) "message"
2) "<channel>"
3) "<message>"
~~~

* channel은 메시지를 구독할 채널을 의미합니다. 여러 채널을 구독할 수 있습니다.
* number는 구독한 채널 순서를 의미합니다.
* message는 발행된 메시지를 의미합니다.
* 구독자가 수행할 수 있는 커맨드는 subscribe, ssubscribe, sunsubscribe, psubscribe, unsubscribe, punsubscribe, ping, reset, quit이 있습니다.

## 클러스터 구조에서의 pub/sub

* Redis 클러스터에서 pub/sub을 사용할 때, 메시지를 발행하면 해당 메시지는 클러스터에 속한 모든 노드에 자동으로 전달됩니다. 
따라서 Redis 클러스터의 아무 노드에 연결해 subscribe 커맨드를 사용하면 데이터를 수신할 수 있습니다.
* Redis 클러스터에서 메시지를 발행하는 방식은 모든 노드에 해당 메시지가 복제되기에 클러스터의 목적인 분산 저장, 처리 목적에 부합하지 않을 수 있습니다.

## sharded pub/sub

* Redis 클러스터의 메시지 발행 비효율성을 해결하기 위해 Redis 7.0에서는 sharded pub/sub 기능이 추가됐습니다.
* sharded pub/sub 환경에서 각 채널은 슬롯에 매핑됩니다. 
클러스터에서 키가 슬롯에 할당되는 것과 동일한 방식으로 채널이 할당되며, 같은 슬롯을 가지고 있는 노드 간에만 pub/sub 메시지를 전파합니다.
* sharded pub/sub에서 메시지를 발행할때는 spublish 커맨드를 사용하며, 메시지를 구독할 때는 ssubscribe 커맨드를 사용합니다.
* sharded pub/sub을 사용하면 모든 노드에 발행된 메시지가 복제되지 않아 자원을 절약할 수 있습니다.

## Redis의 list를 메시징 큐로 사용하기

* Redis의 자료 구조 중 하나인 list는 큐로 사용하기 적절한 자료 구조입니다.
* Redis에는 큐의 tail, head에서 데이터를 넣고 뺄 수 있는데 LPUSH, RPUSH, LPOP, RPOP 커맨드를 사용합니다.

### list의 ex 기능

* Redis의 ex 기능, 예를들어 RPUSHX 커맨드를 사용하면 해당 키가 존재할 때만 데이터를 넣을 수 있습니다.
* 이 기능을 이용하면 특정 키가 존재할 때만 데이터를 넣을 수 있기에, 메시지를 발행할 때 해당 채널에 구독자가 존재할 때만 메시지를 발행할 수 있습니다.
* 이 기능을 통해 애플리케이션에서 해당 채널이 유효한지 확인하는 과정이 필요 없어지며 모든 로직을 Redis에서 처리할 수 있기에 불필요한 확인 과정을 줄여 성능을 향상시킬 수 있습니다.

### list의 블로킹 기능

* Redis를 이벤트 큐로 사용할 경우 블로킹 기능을 유용하게 사용할 수 있습니다.
* 이벤트 기반 구조에서 시스템은 이벤트 루프를 돌며 신규로 처리할 이벤트가 있는지 체크합니다.
* 이벤트 루프는 이벤트 큐에 새 이벤트가 있는지 체크하며, 새로운 이벤트가 없을 경우 정해진 시간 동안 대기한 뒤 다시 이벤트 큐에 데이터가 있는지 확인하는 과정을 반복합니다.
이러한 작업을 폴링이라고 하며, 폴링 프로세스가 진행되는 동안 애플리케이션과 큐의 리소스가 불필요하게 소모될 수 있습니다. 또한 이벤트를 즉시 처리할 수 없다는 단점도 있습니다.
* Redis list의 블로킹 기능을 사용하면 앞선 단점을 해결할 수 있습니다.
* Redis의 RPOP, LPOP에 블로킹을 추가한 BRPOP, BLPOP 커맨드를 사용하면, 데이터가 존재하지 않을 경우 정해진 시간 동안 대기하다가 데이터가 존재하면 데이터를 가져옵니다.

## Stream

* Redis 5.0에 추가된 Stream은 대용량, 대규모의 메시징 데이터를 빠르게 처리할 수 있도록 설계된 자료 구조입니다.
* stream은 데이터를 계속해서 추가하는 방식으로 저장되는(AO, Append Only) 자료 구조입니다.
* stream은 사용 목적에 따라 크게 두 가지 방식으로 활용될 수 있습니다.
  1. 대량의 데이터를 효율적으로 처리하는 플랫폼으로 활용
  2. stream을 여러 생산자가 생성한 데이터를 다양한 소비자가 처리할 수 있게 지원하는 데이터 저장소 및 중간 큐잉 시스템

### 데이터 저장

#### 메시지의 저장과 식별

* 카프카에서 스트림 데이터는 토픽이라는 개념에 저장됩니다. 토픽은 각각의 분리된 스트림을 뜻하며, 같은 데이터를 관리하는 하나의 그룹을 의미합니다.
* Redis에서는 하나의 stream 자료 구조가 하나의 stream을 의미합니다.
* 카프카에서 각 메시지는 0부터 시작해 증가하는 시퀀스 넘버로 식별할 수 있는데, 시퀀스 넘버는 토픽 내의 파티션 안에서만 유니크하게 증가하기에 토픽이 1개 이상의 파티션을 가진다면
메시지는 하나의 토픽 내에서 유니크하게 식별되지 않습니다.
* Redis의 stream에서 각 메시지는 시간과 관련된 유니크한 ID를 가지며, 이 값은 중복되지 않습니다.
~~~
<millisecondsTime>-<sequenceNumber>
~~~
* millisecondsTime은 실제 stream에 아이템이 저장될 시점의 레디스 노드 로컬 시간입니다.
* sequenceNumber는 동일한 millisecondsTime에 여러 아이템이 저장될 수 있으므로, 같은 시간에 저장된 데이터의 순서를 의미합니다.

#### 스트림 생성과 데이터 입력

* 카프카에서 각 스트림은 토픽이라는 이름으로 관리됩니다. 생성자는 데이터를 토픽에 푸시하며, 소비자는 토픽에서 데이터를 읽어갑니다.
* 카프카에서는 데이터를 저장하기 위해 토픽을 먼저 생성한 뒤, 프로듀서를 이용해 메시지를 보낼 수 있습니다.
* Redis에서는 따로 stream을 생성하는 과정은 필요없으며 XADD 커맨드를 이용해 새로운 이름의 stream 데이터를 저장하면 데이터의 저장과 동시에 stream 자료 구조가 생성됩니다.
~~~
> xadd <key> <id> "<field1>" "<value1>" ... "<fieldN>" "<valueN>"
"1703498858736-0"
~~~
* key는 stream의 이름을 의미하며, id는 메시지의 ID를 의미합니다. id에 '*'을 지정하면 Redis에서 타임스탬프 ID를 자동으로 생성합니다.
* field와 value는 메시지의 데이터를 의미합니다. field는 메시지의 키를 의미하며, value는 메시지의 값을 의미합니다. 
또한 field와 value를 여러개 지정하여 json과 같이 복잡한 데이터를 저장할 수 있습니다.
* 커맨드 실행 후 반환되는 값은 메시지의 ID입니다.

#### 데이터의 조회

* 카프카와 Redis stream에서 데이터를 저장하는 방식은 비교적 비슷합니다. 하지만 데이터를 읽어가는 주체, 즉 소비자와 소비자 그룹이 동작하는 방식에서는 분명한 차이가 있습니다.
* 카프카에서는 소비작는 특정 토픽을 실시간으로 리스닝하며, 새롭게 토픽에 저장되는 메시지를 전달받을 수 있습니다.
* Redis stream에서는 데이터를 두 가지 방식으로 읽을 수 있습니다.
  1. 카프카에서처럼 실시간으로 처리되는 데이터를 리스닝하는 방식
  2. ID를 이용해 필요한 데이터를 검색하는 방식
* Redis stream에서 XREAD를 통해 실시간으로 stream에 저장되는 데이터를 읽어올 수 있습니다.
* Redis stream에서 XRANGE, XREVRANGE를 통해 ID를 이용해 필요한 데이터를 검색할 수 있습니다.

#### 소비자와 소비자 그룹

* 같은 데이터를 여러 소비자에게 전달하는 것을 팬아웃(fan-out)이라고 합니다.
* 카프카에서는 토픽을 여러 개의 소비자가 읽어가게 함으로써 간단하게 팬아웃할 수 있습니다.
* Redis stream에서 XREAD 커맨드를 여러 소비자가 수행한다면 팬아웃이 가능합니다.
* stream을 이용해 이벤트 데이터를 처리하는 상황에서 이벤트의 처리 성능을 높이기 위해 여러 소비자를 이용해 병렬적으로 처리되도록 구성할 수 있습니다.
* Redis stream에서는 데이터가 저장될 때마다 고유한 ID를 부여받아 순서대로 저장됩니다. 따라서 소비자에게 데이터가 전달될 때, 순서는 항상 보장됩니다.
* 카프카에서 유니크 키는 파티션 내에서만 보장되게 소비자가 여러 파티션에서 토픽을 읽어갈 때에는 데이터의 순서를 보장할 수 없습니다.

#### 소비자 그룹

* 카프카에서는 소비자 그룹에 여러 소비자를 추가할 수 있으며, 이때 소비자는 토픽 내의 파티션과 일대일로 연결됩니다.
* Redis stream에서의 소비자 그룹은 카프카와 다릅니다. Redis stream에서는 메시지가 전달되는 순서를 신경 쓰지 않아도 되기 때문에 
소비자 그룹 내의 한 소비자는 다른 소비자가 아직 읽지 않은 데이터만 읽어갑니다.
* XREADGROUP 커맨드를 통해 지정한 소비자 그룹을 통해서 데이터를 읽어갑니다.
* 소비자는 처음 언급될 때 자동으로 생성되며 명시적으로 생성할 필요는 없습니다.
* XREADGROUP을 사용하면 여러 stream 데이터를 동시에 읽어올 수 있지만 이를 가능하게 하기 위해서는 stream에 동일한 이름을 가진 소비자 그룹을 먼저 생성해야 합니다.
* XREADGROUP을 사용해 stream 데이터를 읽어올 때, 읽어오는 동작 자체가 소비자 그룹에 영향을 미치기에 일종의 쓰기 커맨드로 생각해야 합니다. 따라서 이 커맨드는 마스터에서만 호출할 수 있습니다.
* 부하 분산 관점에서 카프카는 파티션이라는 개념을 통해 소비자의 부하 분산을 관리한다면 Redis stream은 파티션 없이 소비자 그룹이라는 개념을 이용해 여러 소비자에게 stream의 데이터를 분산시킬 수 있습니다.

#### ACK와 보류 리스트

* 여러 서비스가 메시지 브로커를 이용해 데이터를 처리할 때, 예상하지 못한 장애로 인해 시스템이 종료됐을 경우 이를 재처리할 수 있는 기능이 필요합니다.
* 메시지 브로커는 각 소비자에게 어떤 메시지까지 전달됐고, 전달된 메시지의 처리 유무를 인지하고 있어야 합니다.
* Redis stream에서는 소비자 그룹에 속한 소비자가 메시지를 읽어가면 각 소비자별로 읽어간 메시지에 대한 리스트를 새로 생성하며, 마지막으로 읽어간 데이터 ID로 last_delivered_id 값을 갱신합니다.
* last_delivered_id 값은 해당 소비자 그룹에 마지막으로 전달된 ID가 무엇인지 파악해, 동일한 메시지를 중복으로 전달하지 않기 위해 사용됩니다.
* 카프카도 Redis stream과 비슷하게 파티션별 오프셋을 관리합니다. 카프카는 내부적으로 __consumer_offsets라는 토픽에 데이터를 기록하는데, 
소비자가 지정된 토픽의 특정 파티션의 메시지를 읽으면 소비자 그룹, 토픽, 파티션 내용이 통합돼 저장됩니다. 
소비자 그룹은 __consumer_offsets 토픽에 기록된 정보를 이용해 내부 소비자가 어떤 메시지까지 읽어갔는지 파악할 수 있습니다.
* 카프카의 오프셋은 소비자가 마지막으로 읽은 위치가 아닌 다음으로 읽어야 할 위치를 기록합니다.

#### 메시지의 재할당

* Redis는 소비자에게 장애가 날 경우를 대비해 소비자별 보류 리스트를 유지합니다.
* Redis의 XCLAIM 커맨드를 이용해 메시지 소유권을 다른 소비자에게 할당할 수 있습니다.

#### 메시지의 자동 재할당

* Redis에서는 소비자가 직접 보류했던 메시지 중 하나를 자동으로 가져와서 처리할 수 있도록 하는 XAUTOCLAIM 커맨드를 제공합니다.
* XAUTOCLAIM 커맨드는 할당 대기 중인 다음 메시지의 ID를 반환하는 방식으로 동작하기 때문에 반복적 호출을 가능하게 합니다.