# 내부 임시 테이블

* MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나(ORDER BY) 그루핑(GROUP BY)할 때는 내부적인 임시 테이블(Internal Temporary Table)을 사용합니다.
* 일반적으로 MySQL 엔진이 사용하는 임시 테이블은 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨집니다.
* 특정 예외 케이스에는 메모리를 거치지 않고 바로 디스크에 임시 테이블이 만들어지기도 합니다.
* MySQL 엔진이 내부적인 가공을 위해 생성하는 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수 없으며 사용하는 것도 불가능합니다.
* 내부적인 임시 테이블은 임시 테이블(CREATE TEMPORARY TABLE)과는 달리 쿼리의 처리가 완료되면 자동으로 삭제됩니다.

## 메모리 임시 테이블과 디스크 임시 테이블

* MySQL 8.0 이전 버전까지는 임시 테이블이 메모리를 사용할 때는 MEMORY 스토리지 엔진을, 디스크를 사용할 때는 MyISAM 스토리지 엔진을 사용했습니다.
* MySQL 8.0 이후로는 메모리는 TempTable 스토리지 엔진을, 디스크를 사용할 때는 InnoDB 스토리지 엔진을 사용하도록 개선됐습니다.
* TempTable 스토리지 엔진은 MEMORY 스토리지 엔진과는 다르게 VARBINARY나 VARCHAR 같은 가변 길이 타입을 지원합니다.
* 임시 테이블의 크기가 메모리 스토리지 엔진(TempTable)이 최대 사용 가능한 메모리 공간보다 커지게 되면 임시 테이블을 메모리에서 디스크로 기록하게 됩니다.
* 디스크로 기록하는 저장 방식은 다음과 같습니다.
  * MMAP 파일로 디스크에 기록(기본값)
  * InnoDB 테이블로 기록
* MMAP 파일로 디스크에 기록하는 방식이 기본값인 이유는 InnoDB 테이블로 기록하는 방식에 비해 오버헤드가 적기 때문입니다.

## 임시 테이블이 필요한 쿼리

* MySQL 엔진에서 별도의 가공 작업을 필요로 하는 쿼리의 경우 내부 임시 테이블을 생성합니다.
* MySQL 엔진에서 별도의 가공 작업이 필요한 쿼리는 다음과 같습니다.
  * ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리 (유니크 인덱스)
  * ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리 (유니크 인덱스)
  * DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리 (유니크 인덱스)
  * UNION이나 UNION DISTINCT가 사용된 쿼리(select_type 칼럼이 UNION RESULT 인 경우) (유니크 인덱스)
  * 쿼리의 실행 계획에서 select_typDL DERIVED인 쿼리
* 인덱스를 사용하지 못할 때는 내부 임시 테이블을 생성해야 할 때가 있습니다.
* 쿼리 수행에 있어서 임시 테이블을 사용하는지는 실행 계획의 Extra 칼럼에서 "Using temporary" 메시지 출력 여부로 확인 할 수 있습니다.
* 앞선 쿼리 예시에서 마지막 3개의 쿼리 종류는 실행 계획의 Extra 칼럼에서 "Using temporary" 메시지 출력하지 않더라도 임시 테이블을 사용할 수 있습니다.

## 임시 테이블이 디스크에 생성되는 경우

* 다음과 같은 조건을 만족하면 메모리 임시 테이블을 사용할 수 없어 디스크 기반의 임시 테이블을 사용합니다.
  * UNION이나 UNION ALL에서 SELECT 되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
  * GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
  * 메모리 임시 테이블의 크기가(MEMORY 스토리지 엔진에서) tmp_table_size 또는 max_heap_table_size 시스템 변수보다 크거나(TmpTable 스토리지 엔진에서) temtable_max_ram 시스템 변수 값보다 큰 경우

> 참조
>
> Real MySQL 8.0 1권(https://product.kyobobook.co.kr/detail/S000001766482)